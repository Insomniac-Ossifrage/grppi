# Stream iteration pattern

The **stream iteration** pattern allows loops in data stream processing. An
operation is applied to a data item until a predicate is satisfied. When the
predicate is met, the result is sent to the output stream.

The interface to the **stream iteration** pattern is provided by function
`grppi::repeat_until()`. As all functions in *GrPPI*, this function takes as
its first argument an execution policy.

~~~{.cpp}
grppi::repeat_until(exec, other_arguments...);
~~~

## Stream iteration variants

There is a single variant:

* *Stand-alone stream iteration*: Applies iteration to a stream of values
produced by a generator and invokes a consumer for each value that satisfies
the iteration predicate.

**Note**: Although there is a single variant of stream iteration, the transformation
applied in the iteration loop may be some other composable pattern (**farm** or **pipeline**).

## Key elements in stream iteration

The key elements in a **stream iteration** are a **Transformer** used to transform data items, 
and a **Predicate** that defines when the iteration should finish.

The **Transformer** may be any C++ callable entity that takes a data item and applies
a transformation to it. Thus, a **Transformer** `op` is any operation that, given an input
value `x` of type `T`makes valid the following:

~~~{.cpp}
U res{transformer(x)};
~~~

The **Predicate** may be any C++ callable entity that takes  a data item
and returns a value that is contextually convertible to `bool`.
Thus, a predicate `pred` is any operation, that given a
value `x` of type `T`, makes the following valid:

~~~{.cpp}
do { /*...*/ } while (!predicate(item));
~~~

A stand-alone **stream iteration** also has a **Generator**. The generator may
be any C++ callable entity that produces values in a way that allows to signal
an indication of end-of stream. For this purpose, the **stream iteration**
requires that the generator produces values of any type that is compatible with
a subset of an optional interface:

~~~{.cpp}
auto r = generator(); // r is a value generated by a generator.
if (r) {       // r is convertible to bool
  auto y = *r; // r can be dereferenced.
}
~~~

Additionally, a filter may have a **Consumer**. The consumer may be any C++
callable entity that takes values of the result type of the **Transformer**.

## Details on stream iteration variants

### Stand-alone stream iteration 

A stand alone **stream iteration** has four elements:
 
* A **Generator** of values.
* A **Transformer** of values.
* A **Predicate** for terminating the iteration.
* A **Consumer** of generated values.

---
**Example**: For every natural number x, print the first value x*2^n
that is greater than 1024.
~~~
grppi::repeat_until(ex
  [i=0,max=100]() mutable -> optional<int> {
    if (i<max) return i++;
    else return {};
  },
  [](int x) { return 2*x; },
  [](int x) { return x>1024; },
  [](int x) { cout << x << endl; }
);
~~~
---
