# Filter pattern

The **filter** (or *stream filter*) is a streaming pattern that filters out items
from a data stream based on a predicate, so that only data items satisfying the
predicate are passed to the consumer.

The interface to the **filter** pattern is provided by function
`grppi::stream_filter()`. As all functions in *GrPPI*, this function takes as
its first argument an execution policy.

~~~{.cpp}
grppi::stream_filter(exec, other_arguments...);
~~~

## Stream filter variants

There are two variants:

* *Stand-alone filter*: Applies a filter to a stream of values produced by a
  generator and invokes a consumer for each value satisfying the predicate.
* *Composable filter*: Defines a filter that can be used as a building block by 
   another pattern (e.g. a pipeline).

## Key elements in stream filter

The central element in a **filter** is the **Predicate**. The operation may
be any C++ callable entity. This operation, is a unary operation taking a data
item and returning value that is contextually convertible to `bool`. Thus, a
predicate `pred` is any operation, that given a value `x` of type `T`, makes the
following valid:

~~~{.cpp}
if (predicate(item)) { /*...*/ }.
~~~

A stand-alone **filter** also has a **Generator**. The generator may be any C++
callable entity that produces values in a way that allows to signal an
indication of end-of stream. For this purpose, the **filter** requires that the
generator produces values of any type that is compatible with a subset of an
optional interface:

~~~{.cpp}
auto r = generator(); // r is a value generated by a generator.
if (r) {       // r is convertible to bool
  auto y = *r; // r can be dereferenced.
}
~~~

Additionally, a farm may have a **Consumer**. The consumer may be any C++ callable
entity that takes values of the result type of the Operation.

## Details on stream filter variants

### Stand-alone filter

A stand alone filter has three elements:

* A **Generator** of values.
* A **Predicate** filtering values.
* A **Consumer** of generated values.


---
**Example**: Generate a stream of integer numbers and filter out odd numbers.
~~~{.cpp}
int n = 10;
grppi::stream_filter(exec,
  [&n]() -> std::optional<int> {
    n--;
    if (n>0) return n;
    else     return {};
  },
  [](int x) { return x%2; },
  [](int x) {
    std::cout << x << " ";
  }
);
~~~
---

### Composable filter

A composable filter has a single element:

* A **Predicate** filtering values.

The input values will be generated by the upper level pattern, which will be
also responsible for consuming the output values.

---
**Example**: A filter stage in a pipeline.
~~~{.cpp}
grppi::pipeline(exec,
  stageA,
  stageB,
  grppi::stream_filter(exec, [](auto x) { return x.lenght()>4; }),
  stageC
  );
~~~
---
**Note**: For brevity we do not show here the details of other stages.

For composing complex patterns, the **filter()** function may be used to create
an object that may be supplied to another pattern to build a composed pattern.

---
**Example:**: A composable filter stage in a pipeline.
~~~{.cpp}
auto filter_odd = grppi::stream_filter(exec,
  [](auto x) { return x%2; });

grppi::pipeline(exec,
  stageA,
  stageB,
  filter_odd,
  stageC
  );
~~~
---
**Note**: For brevity we do not show here the details of other stages.
