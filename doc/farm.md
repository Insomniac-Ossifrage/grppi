# Farm pattern

The **farm** pattern (or *task-farm*) is a streaming pattern that applies an operation to every element in a stream.

The interface to the **farm** pattern is provided by function `grppi::farm()`. As all functions in *GrPPI*, this function takes as its first argument an execution policy.

~~~c++
grppi::farm(exec, other_arguments...);
~~~

## Farm variants

There are several variants:

* Stand-alone *farm*: Applies an operation to a sequence of values produced by a generator and invokes a consumer for each generated result.
* Stand-alone *farm* with result discard: Applies an operation to a sequence of values produced by a generator, but ignores the results.
* Composable *farm*: Defines a farm that can be used as a building block by another pattern (e.g. a *pipeline*).

## Key elements in a farm

The central element in a farm is the transformation **Operation**. The operation may be any C++ callable entity. This operation, is a unary operation taking a data item and returning its transformation. 

A *stand-alone farm* also have a **Generator**. The generator may be any C++ callable entity that produces values in a way that allows to signal an indication of end-of stream. For this purpose, the farm requires that te generater produces values of any type that is compatible  with a subset of an optional interface:

~~~c+++
auto r = generator(); // r is a value generated by a generator.

if (r) {       // r is convertible to bool
  auto y = *r; // r can be dereferenced.
}
~~~

Additionally a *farm* may have a **Consumer**. The consumer may be any C++ callable entity that takes values of the result type of the *Operation*.

## Details on farm variants

### Stand-alone farm

A stand-alone farm has three elements

* A **Generator** of values.
* An **Operation** performing a transformation on generated values.
* A **Consumer** of generated values.

---
**Example**
~~~c++
int n = 10;
farm(exec,
  []() -> std::optional<int> {
    n--;
    if (n>0) return n;
    else     {};
  },
  [](int x) { return x*x; },
  [](int x) {
    std::cout << x << " ";
  }
);

~~~
---

### Stand-alone farm with discard

A stand-alone farm with discarding, has two elements.

* A **Generator** of values.
* An **Operation** performing a transformation on generated values.

**Note:** In this case the unary operation results are discarded. Thus, the result type may be `void` or any other type.

---
**Example**
~~~c++
ifstream file{"file.txt"};
farm(exec,
  []() -> std::optional<string> {
    std::string word;
    file >> word;
    if (file) return word;
    else return {};
  },
  [](auto x) {
    if (x.length() > 4) std::cout << x << std::endl;
  },
);
~~~
---

### Composable farm

A *composable farm* has a single element:

* An **Operation** performing a transformation on generated values.

The input values will be generated by the upper level pattern, which will be also repsonsible for consuming the output values.

---
**Example**
~~~c++
pipeline(exec,
  stageA,
  stageB,
  farm(exec,
    [](auto x) {
      if (x.length() > 4) std::cout << x << std::endl;
    },
  stageC
  );
~~~
---
**Note**: For brevity we do not show here the details of other stages.

For composing complex patterns, the `farm()` function may be used to create an object that may be used later in the composition.

---
**Example**
~~~c++
auto print_long_words = farm(exec,
    [](auto x) {
      if (x.length() > 4) std::cout << x << std::endl;
    }

pipeline(exec,
  stageA,
  stageB,
  print_long_words,
  stageC
  );
~~~
---
**Note**: For brevity we do not show here the details of other stages.


